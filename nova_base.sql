INSERT INTO modules (id, name, parent_module_id, created, created_by)
SELECT 210, 'Autenticação LDAP', NULL, NOW(), (SELECT id FROM users WHERE profile_id = 1 ORDER BY id LIMIT 1)
FROM GENERATE_SERIES(1, 1)
WHERE NOT EXISTS (SELECT 1 FROM modules WHERE id = 210);

CREATE TABLE IF NOT EXISTS profiles_authenticators
(
    id          BIGINT       NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    type        SMALLINT     NOT NULL,
    name        VARCHAR(255) NOT NULL,
    domain      VARCHAR(255) NOT NULL,
    port        SMALLINT     NOT NULL,
    created     TIMESTAMP    NOT NULL,
    modified    TIMESTAMP    NULL,
    created_by  BIGINT       NOT NULL,
    modified_by BIGINT       NULL,
    deleted     BOOL         NOT NULL DEFAULT FALSE,
    hash        UUID         NOT NULL DEFAULT uuid(),
    CONSTRAINT pk_profiles_authentication_id PRIMARY KEY (id)
);


ALTER TABLE profiles
    ADD COLUMN IF NOT EXISTS profile_authenticator_id BIGINT DEFAULT NULL;

ALTER TABLE profiles
    ADD COLUMN IF NOT EXISTS hash UUID DEFAULT uuid();

-- modulos habilitados
DROP VIEW IF EXISTS erp.v_allowed_modules;
CREATE VIEW erp.v_allowed_modules AS
SELECT menu.id,
       menu.name,
       menu.parent_menu,
       menu.controller,
       menu.action
FROM menus AS menu
         JOIN permissions_view AS pv ON (pv.controller = menu.controller AND pv.action = menu.action)
WHERE TRUE
  AND parent_menu IS NULL
  AND id != 999000
ORDER BY menu.id;

-- menus permitidos
DROP VIEW IF EXISTS erp.v_allowed_menus;
CREATE VIEW erp.v_allowed_menus AS
SELECT menu.id,
       menu.name,
       menu.parent_menu,
       menu.controller,
       menu.action
FROM menus AS menu
         JOIN permissions_view AS pv ON (pv.controller = menu.controller AND pv.action = menu.action)
         JOIN menus_structure_view AS msv ON (menu.parent_menu = msv.menu_id)
WHERE TRUE
  AND msv.id = 1
ORDER BY menu.id;

-- Alteração para o modo Sub-Tree

ALTER TABLE profiles_authenticators
    ADD COLUMN IF NOT EXISTS search_scope         INTEGER                DEFAULT NULL,
    ADD COLUMN IF NOT EXISTS ldap_user_identifier INTEGER NOT NULL DEFAULT 1,
    ADD COLUMN IF NOT EXISTS ldap_user            CHARACTER VARYING(255) DEFAULT NULL,
    ADD COLUMN IF NOT EXISTS ldap_password        CHARACTER VARYING(255) DEFAULT NULL,
    DROP COLUMN IF EXISTS search_path;

CREATE TABLE IF NOT EXISTS profile_authenticator_search_paths
(
    id                       BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    profile_authenticator_id BIGINT                 NOT NULL,
    search_path              CHARACTER VARYING(255) NOT NULL,
    deleted                  BOOLEAN                         DEFAULT FALSE,
    created                  TIMESTAMP              NOT NULL,
    created_by               BIGINT                 NOT NULL,
    modified                 TIMESTAMP                       DEFAULT NULL,
    modified_by              BIGINT                          DEFAULT NULL,
    hash                     UUID                   NOT NULL DEFAULT uuid(),
    FOREIGN KEY (profile_authenticator_id) REFERENCES profiles_authenticators (id)
);

-- Alteração para indicar caminho de login para o admin
ALTER TABLE profiles_authenticators
    ADD COLUMN IF NOT EXISTS login_path VARCHAR(255) NULL;

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS payable_discount_financial_cost_center_id BIGINT NULL,
    DROP CONSTRAINT IF EXISTS fk_parameters_payable_discount_financial_cost_center_id,
    ADD CONSTRAINT fk_parameters_payable_discount_financial_cost_center_id FOREIGN KEY (payable_discount_financial_cost_center_id) REFERENCES financial_cost_centers (id),
    ADD COLUMN IF NOT EXISTS tariff_financial_cost_center_id           BIGINT NULL,
    DROP CONSTRAINT IF EXISTS tariff_financial_cost_center_id,
    ADD CONSTRAINT tariff_financial_cost_center_id FOREIGN KEY (tariff_financial_cost_center_id) REFERENCES financial_cost_centers (id);

ALTER TABLE financial_collection_types
    ADD COLUMN IF NOT EXISTS tax_financial_cost_center_id BIGINT NULL,
    DROP CONSTRAINT IF EXISTS fk_financial_collection_types_tax_financial_cost_center_id,
    ADD CONSTRAINT fk_financial_collection_types_tax_financial_cost_center_id FOREIGN KEY (tax_financial_cost_center_id) REFERENCES financial_cost_centers (id);

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS phone_invoice_send_method INT4 DEFAULT 1 NOT NULL,
    ADD COLUMN IF NOT EXISTS phone_invoice_extension   INT4 DEFAULT 1 NOT NULL;

ALTER TABLE portal_parameters
    ADD COLUMN IF NOT EXISTS phone_invoice_print_method INT4 DEFAULT 1 NOT NULL;

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS use_origin_team_on_workspace BOOL NULL DEFAULT FALSE;

COMMENT ON COLUMN parameters.use_origin_team_on_workspace
    IS 'Define se constará na tela de atendimento Workspace o campo Equipe de Origem';

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS use_gw_print_billet_engine BOOL NOT NULL DEFAULT TRUE;

ALTER TABLE people
    ADD COLUMN IF NOT EXISTS state_organ        BOOL          NOT NULL DEFAULT FALSE,
    ADD COLUMN IF NOT EXISTS city_organ         BOOL          NOT NULL DEFAULT FALSE,
    ADD COLUMN IF NOT EXISTS pis_aliquot_ret    NUMERIC(5, 2) NULL     DEFAULT 0.00,
    ADD COLUMN IF NOT EXISTS cofins_aliquot_ret NUMERIC(5, 2) NULL     DEFAULT 0.00,
    ADD COLUMN IF NOT EXISTS csll_aliquot_ret   NUMERIC(5, 2) NULL     DEFAULT 0.00,
    ADD COLUMN IF NOT EXISTS irrf_aliquot_ret   NUMERIC(5, 2) NULL     DEFAULT 0.00;

ALTER TABLE service_products
ADD COLUMN IF NOT EXISTS nfcom_fiscal_classification_code varchar(7) DEFAULT NULL;

ALTER TABLE service_products
DROP COLUMN IF EXISTS fust,
DROP COLUMN IF EXISTS funttel;

ALTER TABLE service_products
ADD COLUMN IF NOT EXISTS fust BOOL NOT NULL DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS funttel BOOL NOT NULL DEFAULT FALSE;


ALTER TABLE invoice_note_items
ALTER COLUMN fiscal_classification_code TYPE VARCHAR(7),
DROP COLUMN IF EXISTS nfcom_fiscal_classification_code;

ALTER TABLE financial_operations
ADD COLUMN IF NOT EXISTS fust_calculate bool NOT NULL DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS funttel_calculate bool NOT NULL DEFAULT FALSE;

ALTER TABLE companies_places
ADD COLUMN IF NOT EXISTS fust NUMERIC(5,2) NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS funttel NUMERIC(5,2) NOT NULL DEFAULT 0;

ALTER TABLE invoice_note_items
ADD COLUMN IF NOT EXISTS nfcom_fiscal_classification_code varchar(7) DEFAULT NULL,
ADD COLUMN IF NOT EXISTS fust_aliquot numeric(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS fust_amount numeric(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS fust_base_amount numeric(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS funttel_aliquot numeric(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS funttel_amount numeric(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS funttel_base_amount numeric(12,2) DEFAULT 0.00;

ALTER TABLE invoice_note_items
	ALTER COLUMN fiscal_classification_code TYPE VARCHAR(7),
	ADD COLUMN IF NOT EXISTS fust_aliquot numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS fust_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS fust_base_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_aliquot numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_base_amount numeric(12,2) DEFAULT 0.00;

ALTER TABLE invoice_notes
	ADD COLUMN IF NOT EXISTS fust_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS fust_base_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS fust_tax numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_base_amount numeric(12,2) DEFAULT 0.00,
	ADD COLUMN IF NOT EXISTS funttel_tax numeric(12,2) DEFAULT 0.00;

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS allow_rebuild_anticipated_billing_titles BOOL DEFAULT FALSE NOT NULL;

ALTER TABLE parameters
ADD COLUMN IF NOT EXISTS required_password_open_billing_ticket BOOL DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS required_password_open_invoice_note BOOL DEFAULT FALSE;


ALTER TABLE companies_places
ADD COLUMN IF NOT EXISTS nfe_issuer_supplier INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS nfse_issuer_supplier INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS nfcom_issuer_supplier INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS faktura_integration_code TEXT NULL DEFAULT NULL;


UPDATE companies_places
SET
	nfe_issuer_supplier = (CASE WHEN migrate_nfe = TRUE THEN 1 ELSE 0 END),
	nfse_issuer_supplier = (CASE WHEN migrate_nfse = TRUE THEN 1 ELSE 0 END);


-- Atualiza o local da G6
WITH w_fak AS (
	SELECT
		company_place_id,
		additional_info::JSONB->>'ApiKey' AS api_key,
		additional_info::JSONB->>'VFakturaModelType' AS model_type
	FROM company_place_integrations
	WHERE
		TRUE
		AND additional_info IS NOT NULL
		AND additional_info <> ''
		AND active = TRUE
		AND deleted = FALSE
		AND "type" = 2000
)
UPDATE companies_places AS a
SET
	nfe_issuer_supplier = 2,
	faktura_integration_code = b.api_key
FROM w_fak AS b
WHERE
	TRUE
	AND a.id = b.company_place_id
	AND b.model_type IS NOT NULL
	AND b.api_key IS NOT NULL
	AND b.model_type = '0'
	AND EXISTS (SELECT 1 FROM companies AS x WHERE x.id = 435);

DELETE FROM company_place_integrations
WHERE
	"type" = 2000;

ALTER TABLE regions
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE companies_places
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE company_place_business_units
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE profiles
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

CREATE OR REPLACE
VIEW erp.v_new_service_products_company_balances
AS WITH movimentacao_nf(company_place_id,
service_product_id,
unidades,
wait) AS (
SELECT
	bal_1.company_place_id,
	bal_1.service_product_id,
	COALESCE(sum(
                CASE
                    WHEN itm.inventory_update AND inv.status = 1 THEN
                    CASE
                        WHEN itm.units_decimal IS NULL THEN itm.units::NUMERIC
                        ELSE
                        	CASE
                        		WHEN itm.second_units_measure_id IS NOT NULL THEN itm.units::NUMERIC
                        		ELSE itm.units_decimal
                        	END
                    END
                    ELSE 0::NUMERIC
                END *
                CASE
                    WHEN inv.signal = 1 THEN 1
                    ELSE '-1'::integer
                END::NUMERIC), 0::NUMERIC) + bal_1.opening_balance AS unidades,
	sum(
                CASE
                    WHEN itm.inventory_update IS TRUE AND inv.status = 4 THEN
                    CASE
                        WHEN itm.units_decimal IS NULL THEN itm.units::NUMERIC
                        ELSE
                        	CASE
                        		WHEN itm.second_units_measure_id IS NOT NULL THEN itm.units::NUMERIC
                        		ELSE itm.units_decimal
                        	END
                    END
                    ELSE 0::NUMERIC
                END *
                CASE
                    WHEN inv.signal = 1 THEN 1
                    ELSE '-1'::integer
                END::NUMERIC) AS wait
FROM
	service_products prd_1
JOIN service_product_opening_balances bal_1 ON
	bal_1.service_product_id = prd_1.id
JOIN invoice_notes inv ON
	inv.company_place_id = bal_1.company_place_id
	AND inv.movement_date > bal_1.opening_balance_date
JOIN invoice_note_items itm ON
	inv.id = itm.invoice_note_id
	AND prd_1.id = itm.service_product_id
	AND itm.inventory_update = TRUE
WHERE
	(prd_1.type = ANY (ARRAY[1::bigint,
	4::bigint]))
	AND NOT prd_1.deleted
GROUP BY
	bal_1.company_place_id,
	bal_1.service_product_id
        )
 SELECT
	bal.company_place_id,
	bal.service_product_id,
	bal.opening_balance,
	bal.opening_balance_date,
	COALESCE(tmp.unidades, bal.opening_balance) AS unidades,
	COALESCE(tmp.wait, 0::NUMERIC) AS wait
FROM
	service_products prd
JOIN service_product_opening_balances bal ON
	bal.service_product_id = prd.id
LEFT JOIN movimentacao_nf tmp ON
	bal.company_place_id = tmp.company_place_id
	AND bal.service_product_id = tmp.service_product_id
WHERE
	(prd.type = ANY (ARRAY[1::bigint,
	4::bigint]))
	AND NOT prd.deleted;

ALTER TABLE dashboard_parameters_trust
	ADD COLUMN IF NOT EXISTS present_data_in_consult bool NOT NULL DEFAULT TRUE;

CREATE TABLE IF NOT EXISTS dashboard_parameters_trust_profiles (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    dashboard_parameters_trust_id BIGINT NOT NULL,
    profile_id BIGINT NOT NULL,
    created timestamp NOT NULL DEFAULT NOW(),
    created_by BIGINT NOT NULL,
    modified timestamp NULL,
    modified_by BIGINT NULL,
    PRIMARY KEY (id),
    CONSTRAINT fk_dashboard_parameters_trust FOREIGN KEY (dashboard_parameters_trust_id)
        REFERENCES dashboard_parameters_trust(id),
    CONSTRAINT fk_profile FOREIGN KEY (profile_id)
        REFERENCES profiles(id)
);

ALTER TABLE regions
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE companies_places
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE company_place_business_units
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE profiles
ADD COLUMN IF NOT EXISTS public_id UUID NULL DEFAULT UUID();

ALTER TABLE financial_collection_type_sequences
ADD COLUMN IF NOT EXISTS byte_docket_sequence BIGINT NOT NULL DEFAULT 0;


UPDATE financial_collection_type_sequences AS a
SET
	byte_docket_sequence = TO_CHAR(CURRENT_DATE, 'YY')::BIGINT
FROM financial_collection_types AS b
JOIN bank_accounts AS c ON (c.id = b.bank_account_id)
JOIN banks AS d ON (d.id = c.bank_id)
WHERE
		TRUE
	AND a.financial_collection_type_id = b.id
	AND a.byte_docket_sequence = 0
	AND d.code = '748'
;


DROP FUNCTION IF EXISTS generate_next_bank_title_number;
CREATE OR REPLACE FUNCTION generate_next_bank_title_number(p_financial_collection_type_id BIGINT)
	RETURNS TABLE(
		bank_title_number_sequence BIGINT,
		byte_docket_identification INTEGER,
		byte_docket_sequence INTEGER
	)
	LANGUAGE plpgsql
AS $BODY$

	DECLARE v_actual_sequence 		BIGINT NOT NULL DEFAULT 0;
    DECLARE v_validate_byte   			BIGINT;
   	DECLARE v_validate_byte_sequence	BIGINT;
    DECLARE v_bank_code       			BIGINT;

	BEGIN

		SELECT INTO
			v_bank_code
	        bak.code
	    FROM
	    		 financial_collection_types AS col
	        JOIN bank_accounts         		AS bcc ON (bcc.id = col.bank_account_id)
	        JOIN banks                 		AS bak ON (bak.id = bcc.bank_id)
	    WHERE
	        col.id = p_financial_collection_type_id;

	    SELECT INTO
	    	v_actual_sequence,          	v_validate_byte,				v_validate_byte_sequence
	        col.bank_title_number_sequence, col.byte_docket_identification, col.byte_docket_sequence
	    FROM
	        financial_collection_type_sequences AS col
	    WHERE
	        col.financial_collection_type_id = p_financial_collection_type_id
	    FOR UPDATE;

	    /* Se for SICREDI, deverá fazer o controle do Byte de Bloqueto, que deve ser incrementado em 1 quando o nosso numero chegar em 6 casas*/
	    IF (v_bank_code = 748) THEN

	    	-- Para garantir compatibilidade como era antes, necessário validar se o sequencia é menor que o
	    	-- ano atual, se for, deve atualizar o sequencial com o ano corrente
	    	IF (v_validate_byte_sequence < TO_CHAR(CURRENT_DATE, 'YY')::BIGINT) THEN
	    		v_validate_byte_sequence = TO_CHAR(CURRENT_DATE, 'YY')::BIGINT;
	            v_validate_byte = 2;
		        v_actual_sequence = 0;
	    	END IF;

	    	IF (v_actual_sequence = 99999) THEN
		        IF (v_validate_byte = 9) THEN
		            v_validate_byte = 1;

					-- Incrementa 1 no sequencial do ano (24, 25, 26), sempre que o byte chegar em 9
					v_validate_byte_sequence = v_validate_byte_sequence + 1;
		        END IF;

		        v_validate_byte = v_validate_byte + 1;
		        v_actual_sequence = 0;
	    	END IF;

	    END IF;


	    v_actual_sequence = v_actual_sequence + 1;


	    UPDATE
	        financial_collection_type_sequences
	    SET
	        bank_title_number_sequence = v_actual_sequence,
	        byte_docket_identification = v_validate_byte,
	        byte_docket_sequence = v_validate_byte_sequence
	    WHERE
	        financial_collection_type_id = p_financial_collection_type_id;


	    RETURN query SELECT
			v_actual_sequence::BIGINT AS bank_title_number_sequence,
	        v_validate_byte::INTEGER AS byte_docket_identification,
			v_validate_byte_sequence::INTEGER AS byte_docket_sequence;
	END;
$BODY$
;

ALTER TABLE parameters
    ADD COLUMN IF NOT EXISTS object_remove_category_matrix_id BIGINT NULL,
    DROP CONSTRAINT IF EXISTS fk_parameters_object_remove_category_matrix_id,
    ADD CONSTRAINT fk_parameters_object_remove_category_matrix_id FOREIGN KEY (object_remove_category_matrix_id) REFERENCES solicitation_category_matrices(id);

ALTER TABLE company_place_parameters
    ADD COLUMN IF NOT EXISTS equipment_removal_category_matrix_id BIGINT NULL,
    DROP CONSTRAINT IF EXISTS fk_parameters_equipment_removal_category_matrix_id,
    ADD CONSTRAINT fk_parameters_equipment_removal_category_matrix_id FOREIGN KEY (equipment_removal_category_matrix_id) REFERENCES solicitation_category_matrices(id);
